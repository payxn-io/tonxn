#include "imports/stdlib.fc";

;; Constants
const int MIN_COLLATERAL_RATIO = 150;  ;; 150% minimum collateral ratio
const int ERROR_INVALID_AMOUNT = 101;
const int ERROR_BELOW_MIN_COLLATERAL = 102;
const int ERROR_UNAUTHORIZED = 103;

;; Asset Types
const int TON = 1;
const int DOGS = 2;
const int BTC = 3;
const int ETH = 4;
const int SOL = 5;

;; Storage
global cell users;        ;; Dictionary<addr_std, UserPosition>
global cell price_feeds;  ;; Dictionary<int, int>
global int total_pusd_supply;

;; Storage TL-B
;; UserPosition: (collateral_value:int, pusd_borrowed:int, collaterals:dict)


;; Function Declarations
() load_data() impure;
() save_data() impure;
() deposit_collateral(slice sender_address, int asset_type, int amount) impure;
() borrow_pusd(slice sender_address, int amount) impure;

;; Helper Functions
(int, int, cell) unpack_position(slice cs) inline {
    return (cs~load_uint(128),  ;; collateral_value
            cs~load_uint(128),  ;; pusd_borrowed
            cs~load_dict());    ;; collaterals
}

cell pack_position(int collateral_value, int pusd_borrowed, cell collaterals) inline {
    return begin_cell()
        .store_uint(collateral_value, 128)
        .store_uint(pusd_borrowed, 128)
        .store_dict(collaterals)
        .end_cell();
}

(int, int, int) unpack_collateral(slice cs) inline {
    return (cs~load_uint(8),   ;; asset_type
            cs~load_uint(128), ;; amount
            cs~load_uint(64)); ;; price
}

cell pack_collateral(int asset_type, int amount, int price) inline {
    return begin_cell()
        .store_uint(asset_type, 8)
        .store_uint(amount, 128)
        .store_uint(price, 64)
        .end_cell();
}

() load_data() impure {
    var ds = get_data().begin_parse();
    users = ds~load_ref();
    price_feeds = ds~load_ref();
    total_pusd_supply = ds~load_uint(128);
}

() save_data() impure {
    set_data(begin_cell()
        .store_ref(users)
        .store_ref(price_feeds)
        .store_uint(total_pusd_supply, 128)
        .end_cell());
}